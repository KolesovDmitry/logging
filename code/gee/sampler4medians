var TS = require("users/iglushko/ALERT2018:TimeSeries_test");
var cloudMASK = require("users/iglushko/ALERT2018:L8CloudFilter");
var aggregator = require("users/iglushko/ALERT2018:Aggregator");
var SETS = require("users/iglushko/ALERT2018:TrainTestSets");

var kedrAOI = ee.FeatureCollection('ft:1NfRoqyfZKMuXLBDEbO9II6Rngs43ZlABhzlavlCB');
var fe_mask = ee.FeatureCollection('users/iglushko/FE/aoife');



var forestCover = ee.ImageCollection("GLCF/GLS_TCC").filterDate('2009-12-01', '2011-01-31').mosaic(); //2010 version
forestCover = forestCover.select(['tree_canopy_cover', 'uncertainty']);


//print(train_changes);

var polygons = SETS.SETS.train; //train_clouds
var geom_mask = polygons.union();

// Собираем каналы для генерации обучающей выборки
    var lsat17 = aggregator.Aggregator.createMedians(['LANDSAT/LC08/C01/T1_RT_TOA'], fe_mask, 2017,0, 160, 16);
    var lsat16 = aggregator.Aggregator.createMedians(['LANDSAT/LC08/C01/T1_RT_TOA'], fe_mask, 2016,300, 365, 16);
    var lsat = ee.ImageCollection(lsat16.merge(lsat17));
    
    var lsatMasked = lsat
      .map(function(img){
        // Ожидаемый порядок слоев в изображениях: "blue", "green", "red", "nir", "swir1", "swir2"
        var img_selected = img.select(["blue", "green", "red", "nir", "swir1", "swir2"]);
        var isCloud = cloudMASK.cloudL8Net.cloudMask(img_selected, 0.1);
        return img.updateMask(isCloud.not());
      });
    
    var sliceList = [];
    for (var sliceNum=0; sliceNum<14; sliceNum++){
      sliceList.push(ee.Image('users/kolesovdm/L8Synthesis/before2017/slice_int_'+sliceNum));
    }
    var slices = ee.ImageCollection(sliceList);


// Генерируем обучающую выборку: 
//  1. Создаем точки
//  2. Прицепляем к точкам идентификатор полигона (будут нужны при обучении вовне GEE)
//
//
    
    var SEED = 1;
    var points = ee.FeatureCollection.randomPoints(geom_mask, 10000, SEED);
    var distFilter = ee.Filter.intersects({
      leftField: '.geo',
      rightField: '.geo',
      maxError: 10
    });
    
    var distSave = ee.Join.saveFirst({
      matchKey: 'polygon'//,  measureKey: 'distance'
    });
    
    var spatialJoined = distSave.apply(points, polygons, distFilter);
    spatialJoined = spatialJoined.map(
      function(f){
        return ee.Feature(f.geometry(), {
          'slice': ee.Feature(f.get('polygon')).toDictionary().get('slice'),
          'id': ee.Feature(f.get('polygon')).id()
        });
      }
    );


// Экспорт в CSV
    for (var SLICE_NUM = 0; SLICE_NUM<14; SLICE_NUM++){
      var med = ee.Image(lsatMasked.toList(1, SLICE_NUM).get(0));
      var slice = ee.Image(slices.toList(1, SLICE_NUM).get(0));
      
      //Map.addLayer(slice, {}, 'slice'+SLICE_NUM, false);
      //Map.addLayer(med, {}, 'med'+SLICE_NUM, false);
      
      var data = ee.Image.cat([forestCover, med, slice.updateMask(med), ee.Image(SLICE_NUM).rename('current_slice')]);
      data = data.updateMask(data.reduce(ee.Reducer.allNonZero()));
      
      //get sample
      var sample = data.sampleRegions({
        collection: spatialJoined,
        scale: 30
      });
      // print('First 10 feature (SEED): ', SEED, sample.limit(10));
      
      
      //Export sample_point
      Export.table.toDrive({
        collection: sample,
        description:'change_sample_' + SLICE_NUM + '_seed' + SEED,
        folder: 'EE',
        fileFormat: 'CSV'
      });
      
    }

/*

//Map.addLayer(select, {}, 'select');
//Map.addLayer(notselect, {}, 'notselect');


Map.addLayer(forestCover);
Map.addLayer(lsat);
// Map.addLayer(med, {}, 'm');
//Map.addLayer(slice, {}, 'c');
Map.addLayer(geom_mask);
// Map.addLayer(sample);

*/


