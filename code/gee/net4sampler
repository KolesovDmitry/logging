var TS = require("users/iglushko/ALERT2018:TimeSeries_test");
var cloudMASK = require("users/iglushko/ALERT2018:L8CloudFilter");
var aggregator = require("users/iglushko/ALERT2018:Aggregator");
var neural = require("users/kolesovdm/Neural:trainedNet");
var SETS = require("users/iglushko/ALERT2018:TrainTestSets");


// Импорт исходных данных и генерация необходимых слоев
    
    var forestCover = ee.ImageCollection("GLCF/GLS_TCC").reduce(ee.Reducer.lastNonNull()); 
    forestCover = forestCover.select(['tree_canopy_cover_last']).rename('tree_canopy_cover');
    
    var fe_mask = ee.FeatureCollection('users/iglushko/FE/aoife');
    
    var testPolygons = SETS.SETS.test; 

        
    var lsat18 = aggregator.Aggregator.createMedians(['LANDSAT/LC08/C01/T1_RT_TOA'], fe_mask, 2017, 0, 160, 16);
    var lsat17 = aggregator.Aggregator.createMedians(['LANDSAT/LC08/C01/T1_RT_TOA'], fe_mask, 2016, 300, 365, 16);
    var lsat = ee.ImageCollection(lsat17.merge(lsat18));
    
    var lsatMasked = lsat
      .map(function(img){
        // Ожидаемый порядок слоев в изображениях: "blue", "green", "red", "nir", "swir1", "swir2"
        var img_selected = img.select(["blue", "green", "red", "nir", "swir1", "swir2"]);
        var isCloud = cloudMASK.cloudL8Net.cloudMask(img_selected, 0.1);
        return img.updateMask(isCloud.not());
      });
    
    
    var sliceList = [];
    for (var sliceNum=0; sliceNum<14; sliceNum++){
      sliceList.push(ee.Image('users/kolesovdm/L8Synthesis/before2017/slice_int_'+sliceNum));
    }
    var slices = ee.ImageCollection(sliceList);


// Расчет изменений в срезе SLICE_NUM
    for (var SLICE_NUM=0; SLICE_NUM<14; SLICE_NUM++){
      //var SLICE_NUM = 8;
      
      var med = ee.Image(lsatMasked.toList(1, SLICE_NUM).get(0));
      var slice = ee.Image(slices.toList(1, SLICE_NUM).get(0)).expression('b("blue", "green", "red", "nir", "swir1", "swir2")/10000.0');
              
      var data = ee.Image.cat([med, slice]);
      var mask = data.reduce(ee.Reducer.allNonZero());
      data = data.updateMask(mask);
      
      var arr = data.toArray().toArray(1).arrayTranspose();
      var result = ee.Image(neural.MLP.trained.output(arr));
  
      // С учетом деревьев
      forestCover = forestCover.divide(100.0);
      var dataTC = ee.Image.cat([forestCover, med, slice]);
      var maskTC = dataTC.reduce(ee.Reducer.allNonZero());
      dataTC = dataTC.updateMask(mask);
      
      var arrTC = dataTC.toArray().toArray(1).arrayTranspose();
      var resultTC = ee.Image(neural.MLP.changeDetectorTreeCover.output(arrTC));
      
      // Пуассоновская модель (Перепутан порядок слоев -- тут это нарочно)
      var medP = med.select(["blue", "green", "nir", "red", "swir1", "swir2"]);
      var sliceP = slice.select(["blue", "green", "nir", "red", "swir1", "swir2"]);
              
      var dataP = ee.Image.cat([medP, sliceP]);
      var maskP = data.reduce(ee.Reducer.allNonZero());
      dataP = dataP.updateMask(mask);
      
      var arrP = data.toArray().toArray(1).arrayTranspose();
      var resultP = ee.Image(neural.MLP.changePoisson.output(arrP));
  
  
  // Численная оценка качества результатов для изменений в срезе SLICE_NUM
      var sliceChanges = testPolygons.filter(ee.Filter.eq('slice', SLICE_NUM));
      var changeStat = result.reduceRegions(sliceChanges, ee.Reducer.mean(), 60);
      var cm = changeStat.aggregate_mean('mean');
    
      var sliceNoChanges = testPolygons.filter(ee.Filter.eq('slice', -1));
      // Нужно использовать масштаб 60, но тогда не влазит в память, поэтому 1200
      var nochangeStat = result.reduceRegions(sliceNoChanges, ee.Reducer.mean(), 1200);
      var ncm = nochangeStat.aggregate_mean('mean');

      print('Change Mean, slice ' + SLICE_NUM);
      print(cm);
      
      print('NoChange Mean, slice ' + SLICE_NUM);
      print(ncm);
      
      Map.addLayer(slice, {'min':0, 'max': 1}, 'expected, slice' + SLICE_NUM, false);
      Map.addLayer(med, {}, 'medians, slice' + SLICE_NUM, false);
      
      Map.addLayer(result, {'min':0, 'max': 1, palette: ['blue', 'red']}, 'Changed Result slice' + SLICE_NUM, false);
      Map.addLayer(resultTC, {'min':0, 'max': 1, palette: ['blue', 'red']}, 'Changed Result TC slice' + SLICE_NUM, false);
    
      Map.addLayer(resultTC, {'min':0, 'max': 30, palette: ['red', 'blue']}, 'Changed Result Poisson slice' + SLICE_NUM, false);

    
    }

/*
Export.image.toDrive({
  image: result.multiply(2).round().int8(),
  description:'dates1718_' + SLICE_NUM,
  scale: 60,
  region: fe_mask,
  maxPixels: 500000000
});
*/



// Map.addLayer(forestCover, {'min':0, 'max': 1}, 'ForestCover 2010');
Map.addLayer(changeStat, {}, 'Change polygons');
Map.addLayer(nochangeStat, {}, 'No change polygons');



